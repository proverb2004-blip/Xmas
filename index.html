<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Christmas Memory Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ✅ Import Map：解决 three / examples 模块解析 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at top, #123026, #000);
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #upload {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    input {
      background: #143228;
      color: #ffffff;
      border: none;
      padding: 6px 10px;
    }

    #ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #d4af37;
      font-size: 14px;
      opacity: 0.85;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="upload">
    <input type="file" id="photos" multiple accept="image/*" />
  </div>

  <div id="ui">
    拖拽散开 · 旋转查看 · 点击照片 · 画圆合拢
  </div>

  <!-- ==================== 主程序 ==================== -->
  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";

    /* ---------- 场景 ---------- */
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 15, 70);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.set(0, 8, 26);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0); // 透明背景
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    document.body.appendChild(renderer.domElement);

    /* ---------- 后期 ---------- */
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(
      new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.45,
        0.85
      )
    );

    /* ---------- 灯光 ---------- */
    scene.add(new THREE.AmbientLight(0x335544, 0.7));

    const pointLight = new THREE.PointLight(0xffd8a8, 2.4, 80);
    pointLight.position.set(10, 25, 10);
    scene.add(pointLight);

    /* ---------- 圣诞树装饰 ---------- */
    const COUNT = 600;
    const dummy = new THREE.Object3D();

    function conePosition() {
      const h = Math.random() * 16;
      const r = (1 - h / 16) * 6;
      const a = Math.random() * Math.PI * 2;
      return new THREE.Vector3(
        Math.cos(a) * r,
        h - 8,
        Math.sin(a) * r
      );
    }

    const decoGeometry = new THREE.SphereGeometry(0.22, 16, 16);
    const decoMaterial = new THREE.MeshStandardMaterial({
      color: 0xd4af37,
      metalness: 0.9,
      roughness: 0.25
    });

    const decorations = new THREE.InstancedMesh(
      decoGeometry,
      decoMaterial,
      COUNT
    );

    for (let i = 0; i < COUNT; i++) {
      dummy.position.copy(conePosition());
      dummy.updateMatrix();
      decorations.setMatrixAt(i, dummy.matrix);
    }

    scene.add(decorations);

    /* ---------- 照片 ---------- */
    const photoGroup = new THREE.Group();
    scene.add(photoGroup);

    const textureLoader = new THREE.TextureLoader();
    let focusedPhoto = null;
    let mode = "SCATTERED";

    document.getElementById("photos").addEventListener("change", (e) => {
      const files = Array.from(e.target.files);
      files.forEach((file) => {
        const url = URL.createObjectURL(file);
        textureLoader.load(url, (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace;
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true
          });
          const geometry = new THREE.PlaneGeometry(2.2, 2.2);
          const mesh = new THREE.Mesh(geometry, material);

          const cone = conePosition();
          mesh.position.copy(cone);

          mesh.userData = {
            cone: cone.clone(),
            scatter: new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(35),
              THREE.MathUtils.randFloatSpread(20),
              THREE.MathUtils.randFloatSpread(35)
            )
          };

          photoGroup.add(mesh);
        });
      });
    });

    /* ---------- 交互 ---------- */
    let isDown = false;
    let lastX = 0;
    let lastY = 0;
    let dragDist = 0;

    window.addEventListener("mousedown", (e) => {
      isDown = true;
      lastX = e.clientX;
      lastY = e.clientY;
      dragDist = 0;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDown) return;

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      dragDist += Math.abs(dx) + Math.abs(dy);

      if (mode === "SCATTERED") {
        camera.rotation.y -= dx * 0.002;
        camera.rotation.x -= dy * 0.002;
      }

      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener("mouseup", () => {
      if (dragDist > 180) {
        mode = "SCATTERED";
      } else {
        mode = "COLLAPSED";
        focusedPhoto = null;
      }
      isDown = false;
    });

    /* ---------- 点击照片 ---------- */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener("click", (e) => {
      if (mode !== "SCATTERED") return;

      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(photoGroup.children);

      if (hits.length > 0) {
        focusedPhoto = hits[0].object;
        mode = "FOCUS";
      }
    });

    /* ---------- 动画 ---------- */
    function animate() {
      requestAnimationFrame(animate);

      photoGroup.children.forEach((p) => {
        let target = null;

        if (mode === "COLLAPSED") target = p.userData.cone;
        if (mode === "SCATTERED") target = p.userData.scatter;
        if (mode === "FOCUS") {
          if (p === focusedPhoto) {
            target = camera.position
              .clone()
              .add(
                camera
                  .getWorldDirection(new THREE.Vector3())
                  .multiplyScalar(6)
              );
          } else {
            target = p.userData.scatter;
          }
        }

        if (target) {
          p.position.lerp(target, 0.08);
        }
      });

      composer.render();
    }

    animate();

    /* ---------- Resize ---------- */
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

