<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<script type="importmap">
	{
  	"imports": {
 	   "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
 	   "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
 	 }
	}
	</script>

	<meta charset="UTF-8">
	<title>Christmas Memory Tree</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		html,body{
  		margin:0;
 		overflow:hidden;
  		background:radial-gradient(circle at top,#123026,#000);
  		font-family: -apple-system, BlinkMacSystemFont, sans-serif;
		}

    <meta charset="UTF-8">
    <title>3D 电影感圣诞照片云</title>
    <style>
        body { margin: 0; background: #050a05; overflow: hidden; font-family: "Microsoft YaHei", sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* UI 层 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #d4af37; text-shadow: 0 0 10px rgba(212,175,55,0.5);
        }
        .btn {
            background: rgba(139, 0, 0, 0.6); border: 1px solid #d4af37;
            color: #fff; padding: 8px 15px; cursor: pointer; border-radius: 4px;
            transition: all 0.3s; margin-right: 10px;
        }
        .btn:hover { background: #8b0000; box-shadow: 0 0 15px #d4af37; }
        
        #instruction {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(212,175,55,0.7); pointer-events: none;
        }
        
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h2 style="margin: 0 0 10px 0;">Merry Christmas 2025</h2>
    <button class="btn" onclick="document.getElementById('upload').click()">上传照片</button>
    <input type="file" id="upload" multiple accept="image/*">
    <div id="status" style="margin-top: 10px; font-size: 14px;">状态: 合拢态 (圆圈手势/默认)</div>
</div>

<div id="instruction">
    [交互说明] 画圆:回归圣诞树 | 向外划线:散开粒子 | 鼠标拖拽:旋转视角 | 点击/抓取照片:放大
</div>

<div id="container"></div>

<!-- 引入 Three.js -->
<script type="importmap">
    {
        "imports": {
            "three": "unpkg.com",
            "three/addons/": "unpkg.com"
        }
    }
</script>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";

// --- 配置与变量 ---
let scene, camera, renderer, composer, controls;
let instancedMesh, photoMeshes = [];
const COUNT = 1200; // 装饰物数量
const STATE = { TREE: 0, SCATTER: 1, FOCUS: 2 };
let currentState = STATE.TREE;

// 颜色定义
const COLORS = {
    matteGreen: new THREE.Color(0x1a331a),
    gold: new THREE.Color(0xd4af37),
    red: new THREE.Color(0x8b0000)
};

// 交互辅助
let mouse = new THREE.Vector2();
let raycaster = new THREE.Raycaster();
let tracePoints = [];

// --- 初始化 ---
init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a05, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 20);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('container').appendChild(renderer.domElement);

    // 辉光效果 (Bloom)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.2;
    bloomPass.strength = 1.2;
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // 灯光
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xd4af37, 2);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // 创建实例化网格 (圣诞树装饰物: 球、正方体、棍)
    createInstancedGeometry();

    // 交互监听
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('resize', onWindowResize);
    document.getElementById('upload').addEventListener('change', handleUpload);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false;
}

// --- 创建装饰物 (InstancedMesh) ---
function createInstancedGeometry() {
    // 混合几何体：球、正方体
    const geometries = [
        new THREE.SphereGeometry(0.15, 8, 8),
        new THREE.BoxGeometry(0.2, 0.2, 0.2)
    ];
    
    // 我们用一个合集材质，通过 Instance Color 区分
    const material = new THREE.MeshStandardMaterial({ 
        metalness: 0.9, 
        roughness: 0.2,
        emissiveIntensity: 0.5
    });

    const combinedGeom = geometries[0]; // 简化演示使用球体
    instancedMesh = new THREE.InstancedMesh(combinedGeom, material, COUNT);
    
    const dummy = new THREE.Object3D();
    for (let i = 0; i < COUNT; i++) {
        // 计算树形坐标 (圆锥)
        const ratio = i / COUNT;
        const height = ratio * 15;
        const radius = (1.0 - ratio) * 5;
        const angle = ratio * Math.PI * 40;

        // 存储初始位置（树形）
        const tx = Math.cos(angle) * radius;
        const ty = height - 5;
        const tz = Math.sin(angle) * radius;
        
        dummy.position.set(tx, ty, tz);
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(i, dummy.matrix);

        // 赋予金属金或圣诞红
        const color = Math.random() > 0.5 ? COLORS.gold : COLORS.red;
        instancedMesh.setColorAt(i, color);
    }
    
    scene.add(instancedMesh);
}

// --- 处理照片上传 ---
function handleUpload(e) {
    const files = e.target.files;
    const loader = new THREE.TextureLoader();
    
    for (let i = 0; i < files.length; i++) {
        const url = URL.createObjectURL(files[i]);
        loader.load(url, (texture) => {
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photo = new THREE.Mesh(geometry, material);
            
            // 初始隐藏在树中心
            photo.position.set(0, 0, 0);
            photo.scale.set(0.1, 0.1, 0.1);
            scene.add(photo);
            photoMeshes.push(photo);
            
            if(currentState === STATE.SCATTER) scatterElement(photo);
        });
    }
}

// --- 状态切换逻辑 ---
function transitionTo(newState) {
    if (newState === currentState) return;
    currentState = newState;
    document.getElementById('status').innerText = `状态: ${newState === STATE.TREE ? '合拢态' : '散开态'}`;

    const dummy = new THREE.Object3D();
    
    for (let i = 0; i < COUNT; i++) {
        let targetPos = new THREE.Vector3();
        
        if (newState === STATE.TREE) {
            const ratio = i / COUNT;
            const radius = (1.0 - ratio) * 5;
            const angle = ratio * Math.PI * 40;
            targetPos.set(Math.cos(angle) * radius, ratio * 15 - 5, Math.sin(angle) * radius);
        } else {
            targetPos.set((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30);
        }

        // 使用 TWEEN 做平滑过渡
        const currentM = new THREE.Matrix4();
        instancedMesh.getMatrixAt(i, currentM);
        const startPos = new THREE.Vector3().setFromMatrixPosition(currentM);
        
        new TWEEN.Tween(startPos)
            .to(targetPos, 1500 + Math.random() * 1000)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .onUpdate(() => {
                dummy.position.copy(startPos);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
            })
            .start();
    }

    // 处理照片同步
    photoMeshes.forEach(p => {
        const target = newState === STATE.TREE ? 
            new THREE.Vector3(0,0,0) : 
            new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        
        new TWEEN.Tween(p.position).to(target, 2000).easing(TWEEN.Easing.Exponential.Out).start();
        new TWEEN.Tween(p.scale).to(newState === STATE.TREE ? {x:0.1,y:0.1,z:0.1} : {x:1,y:1,z:1}, 1000).start();
    });
}

// --- 鼠标交互识别 ---
function onMouseDown(e) {
    tracePoints = [];
    
    // 射线检测照片抓取
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(photoMeshes);
    
    if (intersects.length > 0) {
        focusPhoto(intersects[0].object);
    }
}

function onMouseMove(e) {
    if (e.buttons === 1) {
        tracePoints.push({x: e.clientX, y: e.clientY});
    }
}

function onMouseUp(e) {
    if (tracePoints.length < 5) return;

    // 简单的手势判断：
    // 计算位移矢量
    const first = tracePoints[0];
    const last = tracePoints[tracePoints.length - 1];
    const dx = last.x - first.x;
    const dy = last.y - first.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // 1. 如果起点和终点很近，判断为画圆 -> 回到树形
    if (dist < 50 && tracePoints.length > 20) {
        transitionTo(STATE.TREE);
    } 
    // 2. 如果位移很大 -> 散开
    else if (dist > 200) {
        transitionTo(STATE.SCATTER);
    }
}

function focusPhoto(mesh) {
    const targetP = new THREE.Vector3();
    camera.getWorldDirection(targetP);
    targetP.multiplyScalar(5).add(camera.position);

    new TWEEN.Tween(mesh.position)
        .to({ x: targetP.x, y: targetP.y, z: targetP.z }, 800)
        .easing(TWEEN.Easing.Back.Out)
        .start();
    
    mesh.lookAt(camera.position);
}

// --- 渲染循环 ---
function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    
    // 散开态下的微弱漂浮动画
    if (currentState === STATE.SCATTER) {
        const time = Date.now() * 0.0005;
        instancedMesh.rotation.y += 0.001;
        photoMeshes.forEach((p, i) => {
            p.position.y += Math.sin(time + i) * 0.01;
        });
    }

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>

